作业：
1、使用 GCLogAnalysis.java 自己演练一遍串行/并行/CMS/G1的案例。
2、使用压测工具（wrk或sb），演练gateway-server-0.0.1-SNAPSHOT.jar 示例。
3、(选做)如果自己本地有可以运行的项目，可以按照2的方式进行演练。
根据上述自己对于1和2的演示，写一段对于不同 GC 的总结，提交到 Github。

解答：

演练的截图我这里就不放了，以下是通过演练得到的GC总结

串行GC：GC操作是单线程，young GC清理年轻代，Full GC只清理老年代。指定了Xmx，Xms，且两者相等时，年轻代老年代堆大小就固定了，不会改变，比例接近1：2。young GC发生时，年轻代差不多使用了87%，FullGC发生时，老年代几乎使用了100%。串行GC，堆内存越大，GC次数越少，时间也越长。

并行GC：young GC只清理年轻代，Full GC不仅清理老年代，也会把年轻代数据清空。指定了Xmx，Xms，且两者相等时，年轻代老年代堆大小也是在动态变化的。young GC发生时，年轻代使用了87%左右，垃圾回收花费的时间也是随着堆内存增大而变长，但总体时间还是比串行GC快很多。

CMS：年轻代使用的是parNew，老年代使用CMS，使用这种GC策略，年轻代堆空间不能过大，不然清理时，parNew比较花时间。我还观察到堆整体内存>=1G时，年轻代堆内存基本就是固定的，300M左右。CMS执行时，老年代堆内存使用率并没有很高，大概50%左右吧，查了一下，CMS执行Full GC的触发机制还是挺复杂的，并不是堆快满时才执行。堆空间过大，使用CMS并不好，老年代内存使用到一定比例才执行gc，此时一直是young gc，效率不高。

G1：每次GC时间都很短，清理的也比较少，但频率确实比较高，即使堆内存设很大，频率也是这些GC里最高的。

通过分析以上GC，发现 jvm 很多默认值设置的还是比较合理的，比如 Eden:S0:S1=8:1:1，年轻代每次GC后，使用率基本都是10%左右，放在存活区刚好。默认Xmx设置为物理内存的四分之一也很合理，过小容易造成OOM，过大，影响垃圾回收的效率，且系统性能最后也没有很大提升。
通过对比可以看到，并行GC确实是吞吐量最高的，但容易造成高延迟。G1与CMS比，不仅可以控制垃圾回收的时间，吞吐量也比CMS高一些。随着堆内存增大，只有G1的吞吐量在提升，因此堆空间比较大时，比较适合用G1。如果堆空间比较小，这些GC策略性能也相差不大，但我发现堆内存很小时，串行GC吞吐量反而比并行GC大，我觉得可能是并行GC多线程，线程切换也会有开销，此时用串行GC比较好。

